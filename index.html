<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Détection de Mains en Temps Réel [Final]</title>
    <!-- Importation de la police Pixel depuis Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: "Press Start 2P", monospace;
            color: #fff;
        }
        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        video { display: none; }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #title_link {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 6px;
            color: #0f0;
            text-decoration: none;
            z-index: 15;
            padding: 5px;
            transition: background-color 0.2s;
            line-height: 1.5; 
        }
        #title_link:hover {
            background-color: rgba(0, 255, 0, 0.1);
        }
        
        /* --- STYLES POUR LE NOUVEAU MENU --- */
        #show_gui_button {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: transparent;
            color: #0f0;
            border: 1px solid #0f0;
            border-radius: 6px;
            cursor: pointer;
            font-family: "Press Start 2P", monospace;
            width: 50px; /* --- MODIFIÉ --- */
            height: 50px; /* --- MODIFIÉ --- */
            text-shadow: 0 0 3px #0f0;
            transition: background-color 0.2s;
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-size: 7px; 
            text-align: center; 
            padding: 2px; 
            z-index: 10;
        }
        #show_gui_button:hover {
            background-color: rgba(0, 255, 0, 0.1);
        }

        #gui {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 170px; 
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px;
            border: 1px solid #0f0;
            border-radius: 6px;
        }
        
        #hide_gui_button {
            background-color: transparent;
            color: #0f0;
            padding: 4px 6px;
            margin-bottom: 10px;
            border: 1px solid #0f0;
            border-radius: 3px;
            cursor: pointer;
            font-family: "Press Start 2P", monospace;
            font-size: 7px;
            width: 100%;
        }
        #hide_gui_button:hover { 
            background-color: rgba(0, 255, 0, 0.1); 
        }

        .gui-item {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
            justify-content: space-between;
        }
        #gui label {
            color: #fff;
            font-size: 7px;
            margin-right: 5px;
            white-space: nowrap;
        }
        #gui select {
            background-color: #111;
            color: #0f0;
            border: 1px solid #0f0;
            font-family: "Press Start 2P", monospace;
            font-size: 7px;
            padding: 1px;
            width: 80px;
        }
        #gui input[type="checkbox"] {
            appearance: none;
            width: 10px;
            height: 10px;
            border: 1px solid #0f0;
            background-color: #111;
            cursor: pointer;
            position: relative;
            top: 1px;
        }
        #gui input[type="checkbox"]:checked {
            background-color: #0f0;
            box-shadow: 0 0 3px #0f0;
        }
        #gui #reset_button {
            background-color: transparent;
            color: #0f0;
            padding: 4px 6px;
            border: 1px solid #0f0;
            border-radius: 3px;
            cursor: pointer;
            font-family: "Press Start 2P", monospace;
            font-size: 7px;
            width: 100%;
            margin-top: 5px;
        }
        #gui #reset_button:hover { background-color: rgba(0, 255, 0, 0.1); }
        /* --- FIN DES STYLES DU NOUVEAU MENU --- */

        #start_game_button {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background-color: transparent;
            color: #0f0;
            padding: 8px 13px;
            border: 2px solid #0f0;
            border-radius: 3px;
            cursor: pointer;
            font-family: "Press Start 2P", monospace;
            font-size: 8px;
            z-index: 10;
            text-shadow: 0 0 3px #0f0;
        }
        #start_game_button:hover { background-color: rgba(0, 255, 0, 0.15); }
        #game_ui {
            display: none;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0; left: 0;
            z-index: 20;
        }
        #timer {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-size: 24px;
            color: #fff;
            text-shadow: 0 0 8px #f00;
        }
        #score {
            position: absolute;
            bottom: 20px;
            right: 20px;
            font-size: 24px;
            color: #fff;
            text-shadow: 0 0 8px #00f;
        }
        #countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 100px;
            color: #fff;
            text-shadow: 0 0 20px #ff0;
        }
        #volume_control {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 10;
            display: flex;
            align-items: center;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 8px;
            border-radius: 5px;
        }
        #volume_control label {
            font-size: 8px;
            margin-right: 8px;
            color: #fff;
        }

        /* --- STYLE DES CURSEURS VERTICAUX --- */
        .value-indicator {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 15px; 
            height: 300px;
            z-index: 5;
            display: none; 
            pointer-events: none; 
        }
        #indicator_left { left: 20px; }
        #indicator_right { right: 20px; }

        .value-indicator input[type="range"] {
            width: 300px;
            height: 15px; 
            position: absolute;
            top: 142.5px;
            left: -142.5px;
            transform: rotate(-90deg);
        }

        .indicator-value {
            position: absolute;
            font-size: 8px;
            color: #0f0;
            text-shadow: 0 0 3px #0f0;
            transform: translateY(-50%);
        }
        #indicator_left .indicator-value {
            left: 25px;
        }
        #indicator_right .indicator-value {
            right: 25px;
        }
        
        /* --- STYLE DES SLIDERS --- */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            cursor: pointer;
        }
        #gui input[type="range"] { width: 80px; }
        #volume_control input[type="range"] { width: 80px; }
        
        /* Track */
        input[type="range"]::-webkit-slider-runnable-track {
            background: #0f0;
            height: 1px;
        }
        input[type="range"]::-moz-range-track {
            background: #0f0;
            height: 1px;
        }

        /* Thumb */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            margin-top: -6px; 
            background-color: #000;
            border: 1px solid #0f0;
            height: 13px;
            width: 13px;
            border-radius: 50%;
        }
        input[type="range"]::-moz-range-thumb {
            background-color: #000;
            border: 1px solid #0f0;
            height: 13px;
            width: 13px;
            border-radius: 50%;
        }

        /* --- STYLES POUR LE MENU DE SÉLECTION PAR LES MAINS --- */
        .hidden {
            display: none !important;
        }
        #mode_button {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: transparent;
            color: #0f0;
            width: 120px;
            height: 45px;
            border: 2px solid #0f0;
            border-radius: 3px;
            cursor: pointer;
            font-family: "Press Start 2P", monospace;
            font-size: 10px;
            z-index: 25;
            text-shadow: 0 0 4px #0f0;
            transition: background-color 0.2s, color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #mode_button:hover, #mode_button.hovered {
            background-color: #0f0;
            color: #000;
            box-shadow: 0 0 10px #0f0;
        }
        
        #filter_selection_menu {
            position: absolute;
            top: 40px;
            right: 40px;
            bottom: 40px;
            left: 40px;
            z-index: 24;
            display: grid;
            gap: 10px;
            padding: 20px;
            background-color: rgba(0, 15, 0, 0.85);
            border: 2px solid #0f0;
            border-radius: 5px;
        }

        #filter_selection_menu button {
            width: 100%;
            height: 100%;
            padding: 5px;
            background-color: transparent;
            color: #0f0;
            border: 1px solid #0f0;
            font-family: "Press Start 2P", monospace;
            font-size: clamp(7px, 1.1vw, 12px);
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
            text-align: center;
            display: flex;
            justify-content: center;
            align-items: center;
            word-break: break-word;
        }
        #filter_selection_menu button:hover, #filter_selection_menu button.hovered {
            background-color: #0f0;
            color: #000;
        }

        /* --- STYLE POUR LES CURSEURS DE MAIN --- */
        .hand-cursor {
            display: none;
            position: absolute;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background-color: rgba(0, 255, 0, 0.3);
            border: 2px solid #0f0;
            box-shadow: 0 0 8px #0f0;
            z-index: 26;
            pointer-events: none;
            transition: transform 0.1s ease-out;
        }

    </style>
    <!-- Importation des bibliothèques MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/face_detection.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.2/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.1/camera_utils.js" crossorigin="anonymous"></script>
    <!-- Bibliothèque pour le bruit de Perlin (Flow Field) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
</head>
<body>
    <div class="container">
        <a href="https://www.laurentcariou.net/" target="_blank" id="title_link">ERZ<br>DESIGNWORKS<br>COMPUTER<br>VISION,<br>2025</a>
        <video id="webcam" autoplay playsinline></video>
        <canvas id="output_canvas"></canvas>

        <button id="mode_button">MODE</button>
        <div id="filter_selection_menu" class="hidden">
        </div>
        
        <div id="hand_cursor_1" class="hand-cursor"></div>
        <div id="hand_cursor_2" class="hand-cursor"></div>

        <button id="show_gui_button">CTRL</button>

        <div id="gui" class="hidden">
            <button id="hide_gui_button">CLOSE</button>
            <div class="gui-item">
                <label for="max_num_hands">Max Hands:</label>
                <input type="range" id="max_num_hands" min="1" max="4" step="1" value="2">
            </div>
            <div class="gui-item">
                <label for="filter_select">Filter:</label>
                <select id="filter_select">
                    <option value="ascii">ASCII Terminal</option>
                    <option value="bleed">Data Bleed</option>
                    <option value="neural">Neural Network</option>
                    <option value="voronoi">Voronoi Shatter</option>
                    <option value="virtualboy">VIRTUAL BOY</option>
                    <option value="synapse">Cyber Synapse</option>
                    <option value="trace">Trace Corridors</option>
                    <option value="orbital">Orbital Array</option>
                    <option value="hive">Digital Hive</option>
                    <option value="liquidflow">Liquid Flow</option>
                    <option value="spectral">Spectral Grid</option>
                    <option value="modeler">Neural Modeler</option>
                    <option value="asciidistort">ASCII Distort</option>
                    <option value="flowfield">Particle Flow Field</option>
                    <option value="cyberscope">Lissajous Cyberscope</option>
                    <option value="frameglitch">Frame Buffer Glitch</option>
                    <option value="attractor">Strange Attractor</option>
                    <option value="holorain">Holographic Rain</option>
                    <option value="warpdrive">Warp Drive</option>
                    <option value="feedback">Synaptic Feedback</option>
                    <option value="aether">Aetherial Fluid</option>
                    <option value="containment">Antimatter Containment</option>
                    <option value="cryoshards">Cryo-Shards</option>
                    <option value="gravity_well">Gravity Well Emitter</option>
                    <option value="voxel_decomp">Voxelated Decomposition</option>
                    <option value="bifurcation">Bifurcation Diagram</option>
                    <option value="jet">Relativistic Jet</option>
                    <option value="lorenz">Lorenz Attractor</option>
                    <option value="clifford">Clifford Attractor</option>
                    <option value="hopalong">Hopalong Attractor</option>
                </select>
            </div>
            <div class="gui-item">
                <label for="filter_active">Activate Filter:</label>
                <input type="checkbox" id="filter_active">
            </div>
            <div class="gui-item">
                <label for="face_detection_active">Face Detection:</label>
                <input type="checkbox" id="face_detection_active">
            </div>
            <div class="gui-item">
                <label for="fullscreen_checkbox">Fullscreen:</label>
                <input type="checkbox" id="fullscreen_checkbox">
            </div>
            <button id="reset_button">Reset</button>
        </div>

        <div id="game_ui">
            <div id="timer"></div>
            <div id="score"></div>
            <div id="countdown"></div>
        </div>
        <button id="start_game_button">Start Game</button>
        <div id="volume_control">
            <label for="volume_slider">Volume:</label>
            <input type="range" id="volume_slider" min="0" max="0.5" step="0.01" value="0.05">
        </div>

        <div id="indicator_left" class="value-indicator">
            <input type="range" min="0" max="1000" value="0">
            <span class="indicator-value">0</span>
        </div>
        <div id="indicator_right" class="value-indicator">
            <input type="range" min="0" max="1000" value="0">
            <span class="indicator-value">0</span>
        </div>
    </div>

    <script>
        // --- SÉLECTION DES ÉLÉMENTS DOM ---
        const videoElement = document.getElementById('webcam');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const maxNumHandsSlider = document.getElementById('max_num_hands');
        const resetButton = document.getElementById('reset_button');
        const filterCheckbox = document.getElementById('filter_active');
        const filterSelect = document.getElementById('filter_select');
        const faceDetectionCheckbox = document.getElementById('face_detection_active');
        const fullscreenCheckbox = document.getElementById('fullscreen_checkbox'); 
        const startGameButton = document.getElementById('start_game_button');
        const guiElement = document.getElementById('gui');
        const gameUiElement = document.getElementById('game_ui');
        const timerElement = document.getElementById('timer');
        const scoreElement = document.getElementById('score');
        const countdownElement = document.getElementById('countdown');
        const volumeSlider = document.getElementById('volume_slider');
        const titleLink = document.getElementById('title_link');
        const indicatorLeft = document.getElementById('indicator_left');
        const indicatorRight = document.getElementById('indicator_right');
        const indicatorLeftSlider = indicatorLeft.querySelector('input[type="range"]');
        const indicatorRightSlider = indicatorRight.querySelector('input[type="range"]');
        const indicatorLeftLabel = indicatorLeft.querySelector('.indicator-value');
        const indicatorRightLabel = indicatorRight.querySelector('.indicator-value');
        const modeButton = document.getElementById('mode_button');
        const filterSelectionMenu = document.getElementById('filter_selection_menu');
        const handCursor1 = document.getElementById('hand_cursor_1');
        const handCursor2 = document.getElementById('hand_cursor_2');
        const handCursors = [handCursor1, handCursor2];
        
        const showGuiButton = document.getElementById('show_gui_button');
        const hideGuiButton = document.getElementById('hide_gui_button');

        // Instance P5.js pour le bruit de Perlin
        let p5Instance;
        window.addEventListener('load', () => { p5Instance = new p5(); p5.disableFriendlyErrors = true; });

        // --- CACHING DES PARAMÈTRES ---
        const settings = {
            maxNumHands: 2, isFilterActive: false, selectedFilter: 'ascii',
            isFaceDetectionActive: false, globalVolume: 0.05
        };

        // --- Liste des filtres qui ne doivent pas afficher la webcam ---
        const generativeOnlyFilters = [
            'trace', 'orbital', 'liquidflow', 'flowfield', 'cyberscope', 'synapse', 'attractor', 
            'holorain', 'warpdrive', 'aether', 'containment', 'cryoshards',
            'gravity_well', 'bifurcation', 'jet', 'lorenz', 'clifford',
            'hopalong'
        ];

        let hands, faceDetection;
        let handValues = [], handAngles = [], fingertipOrbitalAngle = 0;
        let lastFaceResults = null;

        // --- GESTION DU CLIC PAR SURVOL (DWELL CLICK) ---
        let dwellClickTarget = null;
        let dwellClickStartTime = 0;
        const DWELL_TIME_MS = 900;
        let previouslyHoveredButtons = new Set();
        let numFilters = 0;

        // Variables pour les filtres
        let synapseParticles = [], traceWalkers = [], orbitalPhase = 0;
        let flowParticles = [], modelerRotation = 0;
        let flowFieldParticles = [], lissajousParams = {};
        let previousFrame;
        let attractorParams = {};
        let holorainParticles = [];
        let warpdriveStars = [];
        let feedbackParticles = [];
        let aetherParticles = [];
        let containmentParticles = [];
        let cryoShards = [], cryoParticles = [];
        let gravityParticles = [];
        let voxelDecompParticles = [];
        let bifurcationParticles = [];
        let jetParticles = [];
        let lorenzState = { x: 0.1, y: 0, z: 0 };
        let hextileGrid = [];
        let cliffordState = {x: 0, y: 0};
        let hopalongState = {x: 0, y: 0};
        let hopalongLastResetTime = 0;
        
        // --- AUDIO ---
        let audioCtx;
        let audioNodes = [];
        let isAudioInitialized = false;
        let lastHandValues = [];
        let audioStates = Array(4).fill(null).map(() => ({ value: 0, peak: 0, state: 'decaying' }));
        const ATTACK_DECAY_TIME = 0.1;
        const FRAMES_PER_SECOND = 60;

        // --- JEU ---
        let isGameRunning = false, score = 0, timeLeft = 60;
        let gameInterval = null, countdownInterval = null;
        const playerSize = 40, targetSize = playerSize * 1.7;
        let player = { x: 100, y: 100, size: playerSize };
        let target = { x: 300, y: 300, size: targetSize };
        
        function initializeHands() {
            hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${file}` });
            hands.setOptions({ maxNumHands: settings.maxNumHands, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            hands.onResults(onHandResults);
        }

        function initializeFaceDetection() {
            faceDetection = new FaceDetection({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/${file}` });
            faceDetection.setOptions({ model: 'short', minDetectionConfidence: 0.5 });
            faceDetection.onResults(onFaceResults);
        }

        function onFaceResults(results) {
            lastFaceResults = results;
        }
        
        function updateAudioEnvelopes() {
            for (let i = 0; i < audioStates.length; i++) {
                const state = audioStates[i];
                if (state.peak === 0) continue;
                const increment = state.peak / (FRAMES_PER_SECOND * ATTACK_DECAY_TIME);

                if (state.state === 'attacking') {
                    state.value += increment;
                    if (state.value >= state.peak) {
                        state.value = state.peak;
                        state.state = 'decaying';
                    }
                } else if (state.state === 'decaying') {
                    state.value -= increment;
                    if (state.value <= 0) {
                        state.value = 0;
                        state.peak = 0;
                    }
                }
            }
        }
        
        function updateCursors(multiHandLandmarks, w, h) {
            const menuIsVisible = !filterSelectionMenu.classList.contains('hidden');
            
            handCursors.forEach((cursor, index) => {
                if (menuIsVisible && multiHandLandmarks && multiHandLandmarks[index]) {
                    cursor.style.display = 'block';
                    const indexTip = multiHandLandmarks[index][8];
                    const tipX = (1 - indexTip.x) * w;
                    const tipY = indexTip.y * h;
                    const cursorSize = 15;
                    cursor.style.left = (tipX - cursorSize / 2) + 'px';
                    cursor.style.top = (tipY - cursorSize) + 'px';
                } else {
                    cursor.style.display = 'none';
                }
            });
        }
        
        function handleDwellClick(multiHandLandmarks, w, h) {
            const menuIsVisible = !filterSelectionMenu.classList.contains('hidden');
            if (!multiHandLandmarks || multiHandLandmarks.length === 0) {
                for (const btn of previouslyHoveredButtons) {
                    btn.classList.remove('hovered');
                }
                previouslyHoveredButtons.clear();
                dwellClickTarget = null;
                return;
            }

            const clickableElements = [modeButton, ...filterSelectionMenu.querySelectorAll('button')];
            const currentlyHoveredButtons = new Set();
            let primaryHoveredButton = null;
            let primaryActiveHandLandmarks = null;

            for (const landmarks of multiHandLandmarks) {
                const indexTip = landmarks[8];
                const tipX = (1 - indexTip.x) * w;
                const tipY = indexTip.y * h;

                for (const button of clickableElements) {
                    if (!menuIsVisible && button.id !== 'mode_button') continue;
                    
                    const rect = button.getBoundingClientRect();
                    if (tipX > rect.left && tipX < rect.right && tipY > rect.top && tipY < rect.bottom) {
                        currentlyHoveredButtons.add(button);
                        if (!primaryHoveredButton) {
                            primaryHoveredButton = button;
                            primaryActiveHandLandmarks = landmarks;
                        }
                    }
                }
            }

            for (const btn of previouslyHoveredButtons) {
                if (!currentlyHoveredButtons.has(btn)) {
                    btn.classList.remove('hovered');
                }
            }
            for (const btn of currentlyHoveredButtons) {
                if (!previouslyHoveredButtons.has(btn)) {
                    btn.classList.add('hovered');
                }
            }
            
            previouslyHoveredButtons = currentlyHoveredButtons;

            if (primaryHoveredButton) {
                if (primaryHoveredButton !== dwellClickTarget) {
                    dwellClickTarget = primaryHoveredButton;
                    dwellClickStartTime = performance.now();
                } else {
                    const elapsedTime = performance.now() - dwellClickStartTime;
                    if (elapsedTime >= DWELL_TIME_MS) {
                        dwellClickTarget.click();
                        dwellClickTarget = null; 
                        dwellClickStartTime = 0;
                        previouslyHoveredButtons.forEach(b => b.classList.remove('hovered'));
                        previouslyHoveredButtons.clear();
                    }
                }
            } else {
                dwellClickTarget = null;
                dwellClickStartTime = 0;
            }

            if (dwellClickTarget && primaryActiveHandLandmarks) {
                const elapsedTime = performance.now() - dwellClickStartTime;
                const remainingTime = DWELL_TIME_MS - elapsedTime;
                let countdownNumber;
                if (remainingTime > DWELL_TIME_MS * 0.75) { countdownNumber = 3; }
                else if (remainingTime > DWELL_TIME_MS * 0.50) { countdownNumber = 2; }
                else if (remainingTime > DWELL_TIME_MS * 0.25) { countdownNumber = 1; }
                else { countdownNumber = 0; }

                if (remainingTime > 0) {
                    const indexTip = primaryActiveHandLandmarks[8];
                    const tipX = (1 - indexTip.x) * w;
                    const tipY = indexTip.y * h;
                    canvasCtx.save();
                    canvasCtx.fillStyle = '#0f0';
                    canvasCtx.font = '20px "Press Start 2P"';
                    canvasCtx.textAlign = 'center';
                    canvasCtx.textBaseline = 'middle';
                    canvasCtx.shadowColor = '#0f0';
                    canvasCtx.shadowBlur = 8;
                    canvasCtx.fillText(countdownNumber, tipX, tipY - 40);
                    canvasCtx.restore();
                }
            }
        }

        function onHandResults(results) {
            const w = canvasElement.width;
            const h = canvasElement.height;
            const videoW = videoElement.videoWidth;
            const videoH = videoElement.videoHeight;

            fingertipOrbitalAngle += 0.05;
            updateAudioEnvelopes();

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0 && !isAudioInitialized) initAudio();
            
            if (w > 0 && h > 0) {
                if (!previousFrame) {
                    previousFrame = document.createElement('canvas');
                    previousFrame.width = w;
                    previousFrame.height = h;
                }
                const prevCtx = previousFrame.getContext('2d');
                prevCtx.drawImage(canvasElement, 0, 0);
            }

            // --- LOGIQUE DE RENDU AMÉLIORÉE ---

            // 1. Calculer systématiquement la transformation de l'aspect ratio
            let videoTransform = null;
            if (videoW > 0 && videoH > 0) {
                const canvasRatio = w / h;
                const videoRatio = videoW / videoH;
                let sx, sy, sWidth, sHeight;

                if (canvasRatio > videoRatio) {
                    sWidth = videoW;
                    sHeight = videoW / canvasRatio;
                    sx = 0;
                    sy = (videoH - sHeight) / 2;
                } else {
                    sHeight = videoH;
                    sWidth = videoH * canvasRatio;
                    sy = 0;
                    sx = (videoW - sWidth) / 2;
                }
                videoTransform = { sx, sy, sWidth, sHeight };
            }

            canvasCtx.save();
            canvasCtx.clearRect(0, 0, w, h);

            // 2. Afficher la vidéo (si nécessaire) en utilisant la transformation pré-calculée
            const shouldShowWebcam = !settings.isFilterActive || !generativeOnlyFilters.includes(settings.selectedFilter);
            if (shouldShowWebcam && videoTransform) {
                canvasCtx.save();
                canvasCtx.translate(w, 0);
                canvasCtx.scale(-1, 1);
                canvasCtx.drawImage(videoElement, videoTransform.sx, videoTransform.sy, videoTransform.sWidth, videoTransform.sHeight, 0, 0, w, h);
                canvasCtx.restore();
            }

            // 3. Transformer systématiquement les coordonnées des mains et du visage
            let transformedMultiHandLandmarks = results.multiHandLandmarks;
            if (videoTransform && results.multiHandLandmarks) {
                transformedMultiHandLandmarks = results.multiHandLandmarks.map(hand => 
                    hand.map(lm => ({
                        ...lm,
                        x: ((lm.x * videoW) - videoTransform.sx) / videoTransform.sWidth,
                        y: ((lm.y * videoH) - videoTransform.sy) / videoTransform.sHeight
                    }))
                );
            }
            let transformedFaceDetections = lastFaceResults ? lastFaceResults.detections : null;
            if (videoTransform && transformedFaceDetections) {
                transformedFaceDetections = lastFaceResults.detections.map(det => ({
                    ...det,
                    boundingBox: {
                        ...det.boundingBox,
                        xCenter: ((det.boundingBox.xCenter * videoW) - videoTransform.sx) / videoTransform.sWidth,
                        yCenter: ((det.boundingBox.yCenter * videoH) - videoTransform.sy) / videoTransform.sHeight,
                        width: (det.boundingBox.width * videoW) / videoTransform.sWidth,
                        height: (det.boundingBox.height * videoH) / videoTransform.sHeight,
                    },
                    landmarks: det.landmarks.map(lm => ({
                        ...lm,
                        x: ((lm.x * videoW) - videoTransform.sx) / videoTransform.sWidth,
                        y: ((lm.y * videoH) - videoTransform.sy) / videoTransform.sHeight
                    }))
                }));
            }
            
            // --- FIN DE LA LOGIQUE AMÉLIORÉE ---
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handValues = [], handAngles = [];
                for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                    const landmarks = results.multiHandLandmarks[i]; 
                    const thumbTip = landmarks[4], indexTip = landmarks[8];
                    const distance = Math.hypot((thumbTip.x - indexTip.x) * videoW, (thumbTip.y - indexTip.y) * videoH);
                    
                    const maxDist = 0.225 * videoW;
                    const minDist = 0.05 * videoW;
                    let value = distance > minDist ? Math.round(((distance - minDist) / (maxDist - minDist)) * 1000) : 0;
                    
                    value = Math.max(0, Math.min(value, 1000));
                    handValues.push(value);
                    const deltaX = (indexTip.x - thumbTip.x) * videoW, deltaY = (indexTip.y - thumbTip.y) * videoH;
                    const angleRad = Math.atan2(deltaY, deltaX);
                    handAngles.push(angleRad);
                }
            } else {
                handValues = [];
            }
            
            const sliderHeight = 300, thumbHeight = 13, trackHeight = sliderHeight - thumbHeight;
            if (handValues[0] !== undefined) {
                indicatorRight.style.display = 'block';
                const roundedValue = Math.round(handValues[0]);
                indicatorRightSlider.value = roundedValue;
                indicatorRightLabel.textContent = roundedValue;
                indicatorRightLabel.style.top = `${(trackHeight * (1 - roundedValue / 1000)) + (thumbHeight / 2)}px`;
            } else {
                indicatorRight.style.display = 'none';
            }
            if (handValues[1] !== undefined) {
                indicatorLeft.style.display = 'block';
                const roundedValue = Math.round(handValues[1]);
                indicatorLeftSlider.value = roundedValue;
                indicatorLeftLabel.textContent = roundedValue;
                indicatorLeftLabel.style.top = `${(trackHeight * (1 - roundedValue / 1000)) + (thumbHeight / 2)}px`;
            } else {
                indicatorLeft.style.display = 'none';
            }

            if (settings.isFilterActive && filterSelectionMenu.classList.contains('hidden')) {
                filterFunctions[settings.selectedFilter](transformedMultiHandLandmarks, results.multiHandedness);
            }
            
            if (settings.selectedFilter !== 'hopalong') hopalongLastResetTime = 0;
            
            if(isAudioInitialized) audioNodes.forEach(node => node.gain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.02));

            canvasCtx.save();
            canvasCtx.translate(w, 0);
            canvasCtx.scale(-1, 1);

            if (settings.isFaceDetectionActive && transformedFaceDetections) {
                drawFaceDetections(transformedFaceDetections, w, h);
            }

            if (transformedMultiHandLandmarks && transformedMultiHandLandmarks.length > 0) {
                for (let i = 0; i < transformedMultiHandLandmarks.length; i++) {
                    const value = handValues[i];
                    const angleRad = handAngles[i];
                    const lastValue = lastHandValues[i] || value;
                    const velocity = Math.abs(value - lastValue);
                    if (velocity > 15) {
                        audioStates[i].state = 'attacking';
                        audioStates[i].peak = mapValue(velocity, 15, 300, 0.2, 1.0);
                    }
                    lastHandValues[i] = value;
                    updateAudio(i, audioStates[i].value, angleRad);
                    
                    drawHandSkeleton(transformedMultiHandLandmarks[i], w, h);
                    drawHandUI(transformedMultiHandLandmarks[i], value, angleRad, w, h, i);
                }
                if (transformedMultiHandLandmarks.length < lastHandValues.length) {
                    lastHandValues.length = transformedMultiHandLandmarks.length;
                }
            }
            
            if (transformedMultiHandLandmarks && transformedMultiHandLandmarks.length >= 2) {
                const wrist1 = transformedMultiHandLandmarks[0][0];
                const wrist2 = transformedMultiHandLandmarks[1][0];
                const pos1 = { x: wrist1.x * w, y: wrist1.y * h };
                const pos2 = { x: wrist2.x * w, y: wrist2.y * h };

                canvasCtx.strokeStyle = '#00FF00';
                canvasCtx.lineWidth = 1;
                canvasCtx.setLineDash([2, 3]);
                canvasCtx.beginPath();
                canvasCtx.moveTo(pos1.x, pos1.y);
                canvasCtx.lineTo(pos2.x, pos2.y);
                canvasCtx.stroke();
                canvasCtx.setLineDash([]);
            }
            
            if (settings.isFaceDetectionActive && transformedFaceDetections && transformedFaceDetections.length > 0 && transformedMultiHandLandmarks && transformedMultiHandLandmarks.length > 0) {
                const faceBox = transformedFaceDetections[0].boundingBox;
                const faceAnchorLeft = { x: (faceBox.xCenter + faceBox.width / 2) * w, y: faceBox.yCenter * h };
                const faceAnchorRight = { x: (faceBox.xCenter - faceBox.width / 2) * w, y: faceBox.yCenter * h };
                const handsPos = transformedMultiHandLandmarks.map(landmarks => ({ x: landmarks[0].x * w, y: landmarks[0].y * h }));
                
                canvasCtx.strokeStyle = '#FFFFFF';
                canvasCtx.lineWidth = 1;
                canvasCtx.setLineDash([2, 4]);

                if (handsPos.length === 1) {
                    const hand = handsPos[0];
                    const distToLeft = Math.hypot(hand.x - faceAnchorLeft.x, hand.y - faceAnchorLeft.y);
                    const distToRight = Math.hypot(hand.x - faceAnchorRight.x, hand.y - faceAnchorRight.y);
                    const startPoint = distToLeft < distToRight ? faceAnchorLeft : faceAnchorRight;
                    
                    canvasCtx.beginPath();
                    canvasCtx.moveTo(startPoint.x, startPoint.y);
                    canvasCtx.lineTo(hand.x, hand.y);
                    canvasCtx.stroke();
                } else if (handsPos.length >= 2) {
                    const hand1 = handsPos[0], hand2 = handsPos[1];
                    const dist1ToLeft = Math.hypot(hand1.x - faceAnchorLeft.x, hand1.y - faceAnchorLeft.y);
                    const dist2ToLeft = Math.hypot(hand2.x - faceAnchorLeft.x, hand2.y - faceAnchorLeft.y);
                    const leftHand = dist1ToLeft < dist2ToLeft ? hand1 : hand2;
                    const rightHand = (leftHand === hand1) ? hand2 : hand1;
                    canvasCtx.beginPath();
                    canvasCtx.moveTo(faceAnchorLeft.x, faceAnchorLeft.y);
                    canvasCtx.lineTo(leftHand.x, leftHand.y);
                    canvasCtx.stroke();
                    canvasCtx.beginPath();
                    canvasCtx.moveTo(faceAnchorRight.x, faceAnchorRight.y);
                    canvasCtx.lineTo(rightHand.x, rightHand.y);
                    canvasCtx.stroke();
                }
                canvasCtx.setLineDash([]);
            }
            canvasCtx.restore();

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                canvasCtx.fillStyle = '#00FF00';
                canvasCtx.font = '8px "Press Start 2P"';
                canvasCtx.textAlign = 'center';
                canvasCtx.textBaseline = 'bottom';
                canvasCtx.fillText("HAND CONNECTION ESTABLISHED", w / 2, h - 50);
            } else {
                const time = performance.now() / 1000, blinkSpeed = 0.5;
                const opacity = (Math.sin(time * 2 * Math.PI * blinkSpeed) + 1) / 2;
                canvasCtx.fillStyle = `rgba(0, 255, 0, ${opacity})`;

                const text = "SHOW ME YOUR HANDS";
                let fontSize = 80;
                canvasCtx.font = `${fontSize}px "Press Start 2P"`;
                while (canvasCtx.measureText(text).width > w * 0.5 && fontSize > 10) {
                    fontSize--;
                    canvasCtx.font = `${fontSize}px "Press Start 2P"`;
                }

                canvasCtx.textAlign = 'center';
                canvasCtx.textBaseline = 'middle';
                canvasCtx.fillText(text, w / 2, h / 2);
            }
            
            if (isGameRunning) { updateGame(w, h); drawGameElements(); }
            
            updateCursors(transformedMultiHandLandmarks, w, h);
            handleDwellClick(transformedMultiHandLandmarks, w, h);
        }

        function drawFaceDetections(detections, w, h) { detections.forEach((detection, i) => { const box = detection.boundingBox; const topLeftX = box.xCenter * w - box.width * w / 2; const topLeftY = box.yCenter * h - box.height * h / 2; const boxWidth = box.width * w; const boxHeight = box.height * h; canvasCtx.strokeStyle = '#FFFFFF'; canvasCtx.lineWidth = 1; canvasCtx.setLineDash([10, 4]); canvasCtx.strokeRect(topLeftX, topLeftY, boxWidth, boxHeight); canvasCtx.setLineDash([]); const innerSquareSize = boxWidth * 0.15; const innerSquareX = topLeftX + (boxWidth - innerSquareSize) / 2; const innerSquareY = topLeftY + (boxHeight - innerSquareSize) / 2; canvasCtx.strokeStyle = '#00FF00'; canvasCtx.lineWidth = 1; canvasCtx.strokeRect(innerSquareX, innerSquareY, innerSquareSize, innerSquareSize); for (const landmark of detection.landmarks) { canvasCtx.beginPath(); canvasCtx.arc(landmark.x * w, landmark.y * h, 5, 0, 2 * Math.PI); canvasCtx.stroke(); } if (detection.landmarks.length >= 6) { const leftEye = detection.landmarks[0], rightEye = detection.landmarks[1]; const noseTip = detection.landmarks[2], mouth = detection.landmarks[3]; const leftEar = detection.landmarks[4], rightEar = detection.landmarks[5]; canvasCtx.strokeStyle = '#00FF00'; canvasCtx.lineWidth = 1; canvasCtx.setLineDash([2, 3]); canvasCtx.beginPath(); canvasCtx.moveTo(leftEye.x * w, leftEye.y * h); canvasCtx.lineTo(rightEye.x * w, rightEye.y * h); canvasCtx.stroke(); canvasCtx.beginPath(); canvasCtx.moveTo(leftEar.x * w, leftEar.y * h); canvasCtx.lineTo(rightEar.x * w, rightEar.y * h); canvasCtx.stroke(); canvasCtx.beginPath(); canvasCtx.moveTo(noseTip.x * w, noseTip.y * h); canvasCtx.lineTo(mouth.x * w, mouth.y * h); canvasCtx.stroke(); canvasCtx.beginPath(); canvasCtx.moveTo(leftEye.x * w, leftEye.y * h); canvasCtx.lineTo(mouth.x * w, mouth.y * h); canvasCtx.stroke(); canvasCtx.beginPath(); canvasCtx.moveTo(rightEye.x * w, rightEye.y * h); canvasCtx.lineTo(mouth.x * w, mouth.y * h); canvasCtx.stroke(); canvasCtx.setLineDash([]); } const text_human = `HUMAN ${String(i + 1).padStart(2, '0')}`; const text_human_X = topLeftX + boxWidth; const text_human_Y = topLeftY - 5; canvasCtx.save(); canvasCtx.translate(text_human_X, text_human_Y); canvasCtx.scale(-1, 1); canvasCtx.fillStyle = '#00FF00'; canvasCtx.font = '10px "Press Start 2P"'; canvasCtx.textAlign = 'right'; canvasCtx.textBaseline = 'bottom'; canvasCtx.fillText(text_human, 0, 0); canvasCtx.restore(); const text_connection = "face connection established"; const text_connection_X = topLeftX + boxWidth; const text_connection_Y = topLeftY + boxHeight + 5; canvasCtx.save(); canvasCtx.translate(text_connection_X, text_connection_Y); canvasCtx.scale(-1, 1); canvasCtx.fillStyle = '#00FF00'; canvasCtx.font = '6px "Press Start 2P"'; canvasCtx.textAlign = 'right'; canvasCtx.textBaseline = 'top'; canvasCtx.fillText(text_connection, 0, 0); canvasCtx.restore(); }); }
        function drawHandSkeleton(landmarks, w, h) { const FINGER_TIPS_INDICES = [4, 8, 12, 16, 20]; drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, { color: '#FFFFFF', lineWidth: 1 }); canvasCtx.strokeStyle = '#FFFFFF'; canvasCtx.lineWidth = 1; for (let i = 0; i < landmarks.length; i++) { if (FINGER_TIPS_INDICES.includes(i)) continue; const landmark = landmarks[i]; canvasCtx.beginPath(); canvasCtx.arc(landmark.x * w, landmark.y * h, 5, 0, 2 * Math.PI); canvasCtx.stroke(); } }
        function drawHandUI(landmarks, value, angleRad, w, h, handIndex) { const FINGER_TIPS_INDICES = [4, 8, 12, 16, 20]; const squareSize = 24; const circleDiameter = 45; const circleRadius = circleDiameter / 2; for (let i = 0; i < FINGER_TIPS_INDICES.length; i++) { const landmark = landmarks[FINGER_TIPS_INDICES[i]]; const x = landmark.x * w, y = landmark.y * h; canvasCtx.strokeStyle = '#00FF00'; canvasCtx.lineWidth = 1; canvasCtx.save(); canvasCtx.translate(x, y); canvasCtx.rotate(fingertipOrbitalAngle); canvasCtx.beginPath(); canvasCtx.setLineDash([1, 3]); canvasCtx.arc(0, 0, circleRadius, 0, 2 * Math.PI); canvasCtx.stroke(); canvasCtx.restore(); canvasCtx.strokeRect(x - squareSize / 2, y - squareSize / 2, squareSize, squareSize); const number = String(i + 1).padStart(2, '0'), textX = x + 32, textY = y; canvasCtx.save(); canvasCtx.translate(textX, textY); canvasCtx.scale(-1, 1); canvasCtx.fillStyle = '#00FF00'; canvasCtx.font = '8px "Press Start 2P"'; canvasCtx.textAlign = 'right'; canvasCtx.textBaseline = 'middle'; canvasCtx.fillText(number, 0, 0); canvasCtx.restore(); } const thumbTip = landmarks[4], indexTip = landmarks[8]; const thumbPos = { x: thumbTip.x * w, y: thumbTip.y * h }, indexPos = { x: indexTip.x * w, y: indexTip.y * h }; canvasCtx.beginPath(); canvasCtx.moveTo(thumbPos.x, thumbPos.y); canvasCtx.lineTo(indexPos.x, indexPos.y); canvasCtx.strokeStyle = '#FFFFFF'; canvasCtx.lineWidth = 1; canvasCtx.setLineDash([4, 4]); canvasCtx.stroke(); canvasCtx.setLineDash([]); const midPoint = { x: (thumbPos.x + indexPos.x) / 2, y: (thumbPos.y + indexPos.y) / 2 }; canvasCtx.save(); canvasCtx.translate(midPoint.x, midPoint.y); canvasCtx.scale(-1, 1); canvasCtx.fillStyle = '#FFFFFF'; canvasCtx.font = '12px "Press Start 2P"'; canvasCtx.textAlign = 'center'; canvasCtx.textBaseline = 'middle'; let angleDeg = angleRad * 180 / Math.PI; if (angleDeg < 0) { angleDeg += 360; } canvasCtx.fillText(`${Math.round(angleDeg)}°`, 0, -30); canvasCtx.fillText(value, 0, -15); canvasCtx.restore(); const wrist = landmarks[0]; const wristPos = { x: wrist.x * w, y: wrist.y * h }; const handLabel = `HAND_${String(handIndex + 1).padStart(2, '0')}`; const textX_wrist = wristPos.x + 32; const textY_wrist = wristPos.y; canvasCtx.save(); canvasCtx.translate(textX_wrist, textY_wrist); canvasCtx.scale(-1, 1); canvasCtx.fillStyle = '#00FF00'; canvasCtx.font = '8px "Press Start 2P"'; canvasCtx.textAlign = 'right'; canvasCtx.textBaseline = 'middle'; canvasCtx.fillText(handLabel, 0, 0); canvasCtx.restore(); }

        // --- SECTION AUDIO ---
        function updateAudio(index, envelopeValue, angleRad) { if (isAudioInitialized && audioNodes[index]) { const frequency = mapValue(envelopeValue, 0, 1, 80, 750); const rotationEffect = Math.abs(Math.sin(angleRad)); const node = audioNodes[index]; if (node.type === 'simple') { const lfoRate = rotationEffect * 10; node.lfo.frequency.setTargetAtTime(lfoRate, audioCtx.currentTime, 0.05); node.osc.frequency.setTargetAtTime(frequency, audioCtx.currentTime, 0.05); } else if (node.type === 'fm') { const fmAmount = 50 + rotationEffect * 250; node.modulatorGain.gain.setTargetAtTime(fmAmount, audioCtx.currentTime, 0.05); node.carrier.frequency.setTargetAtTime(frequency, audioCtx.currentTime, 0.05); node.modulator.frequency.setTargetAtTime(frequency * 1.5, audioCtx.currentTime, 0.05); } node.gain.gain.setTargetAtTime(settings.globalVolume, audioCtx.currentTime, 0.02); } }
        async function createReverb(audioContext) { const convolver = audioContext.createConvolver(); const sampleRate = audioContext.sampleRate; const duration = 0.8; const decay = 2.0; const impulse = audioContext.createBuffer(2, duration * sampleRate, sampleRate); for (let i = 0; i < 2; i++) { const channel = impulse.getChannelData(i); for (let j = 0; j < impulse.length; j++) { channel[j] = (Math.random() * 2 - 1) * Math.pow(1 - j / impulse.length, decay); } } convolver.buffer = impulse; return convolver; }
        async function initAudio() { if (isAudioInitialized) return; audioCtx = new (window.AudioContext || window.webkitAudioContext)(); const reverbNode = await createReverb(audioCtx); reverbNode.connect(audioCtx.destination); for (let i = 0; i < 4; i++) { const gainNode = audioCtx.createGain(); gainNode.gain.setValueAtTime(0, audioCtx.currentTime); gainNode.connect(reverbNode); if (i === 0) { const osc = audioCtx.createOscillator(), lfo = audioCtx.createOscillator(), lfoGain = audioCtx.createGain(); lfo.type = 'sine'; lfo.frequency.value = 0; lfoGain.gain.value = 10; lfo.connect(lfoGain).connect(osc.frequency); osc.type = 'sine'; osc.frequency.value = 100; osc.connect(gainNode); lfo.start(); osc.start(); audioNodes.push({ type: 'simple', osc, lfo, gain: gainNode }); } else { const carrier = audioCtx.createOscillator(), modulator = audioCtx.createOscillator(), modulatorGain = audioCtx.createGain(); carrier.type = 'sine'; modulator.type = 'sine'; modulator.connect(modulatorGain).connect(carrier.frequency); carrier.connect(gainNode); carrier.frequency.value = 100; modulator.frequency.value = 150; modulatorGain.gain.value = 50; carrier.start(); modulator.start(); audioNodes.push({ type: 'fm', carrier, modulator, modulatorGain, gain: gainNode }); } } isAudioInitialized = true; }
        
        // --- SECTION DU JEU ---
        function startGame() { if (!isAudioInitialized) initAudio(); guiElement.classList.add('hidden'); showGuiButton.classList.add('hidden'); startGameButton.style.display = 'none'; document.getElementById('volume_control').style.display = 'none'; titleLink.style.display = 'none'; gameUiElement.style.display = 'block'; let count = 3; countdownElement.textContent = count; countdownInterval = setInterval(() => { count--; if (count > 0) { countdownElement.textContent = count; } else { countdownElement.textContent = 'GO!'; setTimeout(() => { countdownElement.textContent = ''; beginGameplay(); }, 1000); clearInterval(countdownInterval); } }, 1000); }
        function beginGameplay() { isGameRunning = true; score = 0; timeLeft = 60; scoreElement.textContent = 'Score: 0'; timerElement.textContent = 'Time: 60'; generateNewTarget(); gameInterval = setInterval(() => { timeLeft--; timerElement.textContent = `Time: ${timeLeft}`; if (timeLeft <= 0) { endGame(); } }, 1000); }
        function endGame() { clearInterval(gameInterval); isGameRunning = false; countdownElement.textContent = `Final Score: ${score}`; setTimeout(() => { gameUiElement.style.display = 'none'; countdownElement.textContent = ''; startGameButton.style.display = 'block'; showGuiButton.classList.remove('hidden'); document.getElementById('volume_control').style.display = 'flex'; titleLink.style.display = 'block';}, 7000); }
        function mapValue(value, in_min, in_max, out_min, out_max) { const clampedValue = Math.max(in_min, Math.min(value, in_max)); return (clampedValue - in_min) * (out_max - out_min) / (in_max - in_min) + out_min; }
        function updateGame(w, h) { if (handValues[0] !== undefined) { player.x = w - mapValue(handValues[0], 100, 750, 0, w - player.size); } if (handValues[1] !== undefined) { player.y = mapValue(handValues[1], 100, 750, 0, h - player.size); } if (player.x > target.x && player.x + player.size < target.x + target.size && player.y > target.y && player.y + player.size < target.y + target.size) { score += 100; scoreElement.textContent = `Score: ${score}`; generateNewTarget(); } }
        function drawGameElements() { canvasCtx.fillStyle = 'rgba(0, 150, 255, 0.8)'; canvasCtx.strokeStyle = '#00f'; canvasCtx.lineWidth = 3; canvasCtx.fillRect(target.x, target.y, target.size, target.size); canvasCtx.strokeRect(target.x, target.y, target.size, target.size); canvasCtx.fillStyle = 'rgba(255, 50, 50, 0.9)'; canvasCtx.strokeStyle = '#f00'; canvasCtx.lineWidth = 3; canvasCtx.fillRect(player.x, player.y, player.size, player.size); canvasCtx.strokeRect(player.x, player.y, player.size, player.size); }
        function generateNewTarget() { const margin = 20; target.x = Math.random() * (canvasElement.width - target.size - margin * 2) + margin; target.y = Math.random() * (canvasElement.height - target.size - margin * 2) + margin; }

        // --- SECTION FILTRES ---
        function applyVirtualBoyFilter() { const virtualBoyPalette = [[60, 0, 0], [120, 0, 0], [190, 0, 0], [255, 20, 20]]; const pixelationControl = handValues.length > 0 ? handValues[0] / 1000 : 0.5; const pixelSize = Math.max(8, Math.floor(20 - (pixelationControl * 12))); const w = canvasElement.width, h = canvasElement.height; const imageData = canvasCtx.getImageData(0, 0, w, h); const data = imageData.data; for (let y = 0; y < h; y += pixelSize) { for (let x = 0; x < w; x += pixelSize) { const i = (y * w + x) * 4; const brightness = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]; let color; if (brightness < 64) color = virtualBoyPalette[0]; else if (brightness < 128) color = virtualBoyPalette[1]; else if (brightness < 192) color = virtualBoyPalette[2]; else color = virtualBoyPalette[3]; canvasCtx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`; canvasCtx.fillRect(x, y, pixelSize, pixelSize); } } }
        function applyVoronoiShatterFilter(multiHandLandmarks) { if (!multiHandLandmarks) return; const glowControl = handValues[0] / 1000 || 0; const chaosControl = handValues[1] / 1000 || (handValues[0] / 1000) || 0; let points = []; multiHandLandmarks.forEach(landmarks => { landmarks.forEach(lm => points.push({x: (1-lm.x) * canvasElement.width, y: lm.y * canvasElement.height})); }); if (points.length < 3) return; const imageData = canvasCtx.getImageData(0,0,canvasElement.width,canvasElement.height); canvasCtx.fillStyle = '#000'; canvasCtx.fillRect(0,0,canvasElement.width,canvasElement.height); points.forEach(p => { p.x += (Math.random() - 0.5) * chaosControl * 20; p.y += (Math.random() - 0.5) * chaosControl * 20; }); for(let i=0; i<points.length; i++) { let neighbors = findNearest(points[i], points, 3); canvasCtx.beginPath(); canvasCtx.moveTo(neighbors[0].x, neighbors[0].y); canvasCtx.lineTo(neighbors[1].x, neighbors[1].y); canvasCtx.lineTo(neighbors[2].x, neighbors[2].y); canvasCtx.closePath(); const avgX = Math.floor((neighbors[0].x + neighbors[1].x + neighbors[2].x) / 3); const avgY = Math.floor((neighbors[0].y + neighbors[1].y + neighbors[2].y) / 3); const pixelIndex = (avgY * canvasElement.width + avgX) * 4; const r = imageData.data[pixelIndex], g = imageData.data[pixelIndex+1], b = imageData.data[pixelIndex+2]; canvasCtx.fillStyle = `rgb(${r},${g},${b})`; canvasCtx.fill(); canvasCtx.strokeStyle = `rgba(255,255,255,${glowControl})`; canvasCtx.lineWidth = glowControl * 3; canvasCtx.stroke(); } }
        function findNearest(point, points, n) { return [...points].sort((a,b) => Math.hypot(point.x-a.x, point.y-a.y) - Math.hypot(point.x-b.x, point.y-b.y)).slice(1, n+1); }
        function applyDataBleedFilter() { const thresholdControl = handValues[0] / 1000 || 0.5; const lengthControl = handValues[1] / 1000 || thresholdControl; const angle = handAngles[0] || Math.PI / 2; const dx = Math.cos(angle); const dy = Math.sin(angle); const imageData = canvasCtx.getImageData(0, 0, canvasElement.width, canvasElement.height); const data = imageData.data; const threshold = thresholdControl * 255; const maxLength = lengthControl * 50; for (let x = 0; x < canvasElement.width; x += 4) { for (let y = 0; y < canvasElement.height; y += 4) { const i = (y * canvasElement.width + x) * 4; if (((data[i] + data[i+1] + data[i+2]) / 3) > threshold) { for (let l = 1; l < maxLength; l += 2) { const bleedX = Math.round(x + l * dx); const bleedY = Math.round(y + l * dy); if (bleedX >= 0 && bleedX < canvasElement.width && bleedY >= 0 && bleedY < canvasElement.height) { const j = (bleedY * canvasElement.width + bleedX) * 4; data[j] = data[i]; data[j+1] = data[i+1]; data[j+2] = data[i+2]; } } } } } canvasCtx.putImageData(imageData, 0, 0); }
        function applyAsciiFilter() { const densityControl = handValues.length > 0 ? handValues[0] / 1000 : 0; const chars = " .:-=+r*#Ze%@"; const resolution = Math.max(6, Math.floor(20 - (densityControl * 14))); const imageData = canvasCtx.getImageData(0, 0, canvasElement.width, canvasElement.height); const data = imageData.data; canvasCtx.fillStyle = '#000000'; canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height); canvasCtx.fillStyle = `hsl(0, 100%, 50%)`; canvasCtx.font = `${resolution}px "Press Start 2P"`; for (let y = 0; y < canvasElement.height; y += resolution) { for (let x = 0; x < canvasElement.width; x += resolution) { const i = (y * canvasElement.width + x) * 4; const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3; const charIndex = Math.floor((brightness / 255) * (chars.length - 1)); canvasCtx.fillText(chars[charIndex], x, y); } } }
        function applyNeuralNetworkFilter() { const densityControl = handValues[0]/1000||0; const glowControl = handValues[1]/1000||(handValues[0]/1000)||0; const resolution = Math.max(10, Math.floor(40 - (densityControl*30))); const connectionDistance = resolution * 1.5; const imageData = canvasCtx.getImageData(0,0,canvasElement.width,canvasElement.height); const data = imageData.data; canvasCtx.fillStyle = '#000'; canvasCtx.fillRect(0,0,canvasElement.width,canvasElement.height); const cols = Math.ceil(canvasElement.width/connectionDistance), rows = Math.ceil(canvasElement.height/connectionDistance); const grid = Array.from({length:rows},()=>Array.from({length:cols},()=>[])); for(let y=0; y<canvasElement.height; y+=resolution){for(let x=0; x<canvasElement.width; x+=resolution){const i = (y*canvasElement.width+x)*4; const brightness = (data[i]+data[i+1]+data[i+2])/3; if(brightness > 50){const node = {x,y,brightness}; const gx = Math.floor(x/connectionDistance), gy = Math.floor(y/connectionDistance); if(grid[gy] && grid[gy][gx]) grid[gy][gx].push(node);}}} canvasCtx.strokeStyle = `rgba(0,255,150,${glowControl*0.5})`; canvasCtx.lineWidth = 0.5; for(let gy=0; gy<rows; gy++){for(let gx=0; gx<cols; gx++){for(const node of grid[gy][gx]){canvasCtx.beginPath(); canvasCtx.arc(node.x,node.y,1,0,Math.PI*2); canvasCtx.fillStyle = `rgba(255,255,255,${node.brightness/255})`; canvasCtx.fill(); for(let ny=-1; ny<=1; ny++){for(let nx=-1; nx<=1; nx++){if(grid[gy+ny] && grid[gy+ny][gx+nx]){for(const neighbor of grid[gy+ny][gx+nx]){if(node === neighbor) continue; if(Math.hypot(node.x-neighbor.x,node.y-neighbor.y) < connectionDistance && Math.random() > 0.5){canvasCtx.beginPath(); canvasCtx.moveTo(node.x,node.y); canvasCtx.lineTo(neighbor.x,neighbor.y); canvasCtx.stroke();}}}}}}}} }
        function applyCyberSynapseFilter(multiHandLandmarks) { const w = canvasElement.width, h = canvasElement.height; const speedControl = handValues[0] / 1000 || 0.3; const densityControl = handValues[1] / 1000 || 0.3; canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.15)'; canvasCtx.fillRect(0, 0, w, h); if (multiHandLandmarks) { for (const landmarks of multiHandLandmarks) { if (Math.random() < densityControl) { const landmark = landmarks[Math.floor(Math.random() * landmarks.length)]; for(let i=0; i < 10; i++) { synapseParticles.push({ x: (1 - landmark.x) * w, y: landmark.y * h, vx: (Math.random() - 0.5) * 3, vy: (Math.random() - 0.5) * 3, life: 50 + densityControl * 100, hue: 120 + Math.random() * 60 }); } } } } for (let p of synapseParticles) { p.x += p.vx; p.y += p.vy; p.vx += (Math.random() - 0.5) * speedControl; p.vy += (Math.random() - 0.5) * speedControl; p.life--; canvasCtx.fillStyle = `hsla(${p.hue}, 100%, 70%, ${p.life / 100})`; canvasCtx.fillRect(p.x, p.y, 2, 2); } synapseParticles = synapseParticles.filter(p => p.life > 0); }
        function applyTraceCorridorsFilter() { const w = canvasElement.width, h = canvasElement.height; const speedControl = 1 + (handValues[0] / 1000 * 100) || 2; const turnChance = 0.01 + (handValues[1] / 1000 * 0.2) || 0.05; if (traceWalkers.length === 0 && w > 0) { for (let i = 0; i < 100; i++) { traceWalkers.push({ x: Math.random() * w, y: Math.random() * h, dir: Math.floor(Math.random() * 4), color: `hsl(${100 + Math.random() * 40}, 100%, 50%)` }); } } const currentHandValue = handValues[0] || 0; const fadeAlpha = mapValue(currentHandValue, 0, 1000, 0.1, 0.002); canvasCtx.fillStyle = `rgba(0, 0, 0, ${fadeAlpha})`; canvasCtx.fillRect(0, 0, w, h); for (const walker of traceWalkers) { canvasCtx.strokeStyle = walker.color; canvasCtx.lineWidth = 2; canvasCtx.shadowColor = walker.color; canvasCtx.shadowBlur = 10; canvasCtx.beginPath(); canvasCtx.moveTo(walker.x, walker.y); if (walker.dir === 0) walker.y -= speedControl; else if (walker.dir === 1) walker.x += speedControl; else if (walker.dir === 2) walker.y += speedControl; else walker.x -= speedControl; canvasCtx.lineTo(walker.x, walker.y); canvasCtx.stroke(); if (walker.x <= 0 && walker.dir === 3) walker.dir = 1; else if (walker.x >= w && walker.dir === 1) walker.dir = 3; else if (walker.y <= 0 && walker.dir === 0) walker.dir = 2; else if (walker.y >= h && walker.dir === 2) walker.dir = 0; if (Math.random() < turnChance) { walker.dir = Math.floor(Math.random() * 4); } } canvasCtx.shadowBlur = 0; }
        function applyOrbitalArrayFilter() { const w = canvasElement.width, h = canvasElement.height; const complexity = 3 + Math.floor((handValues[0] / 1000) * 10) || 3; const speed = handValues[1] / 1000 || 0; orbitalPhase += speed * 0.1; canvasCtx.fillStyle = 'rgba(0,0,0,0.1)'; canvasCtx.fillRect(0,0,w,h); canvasCtx.strokeStyle = '#0f0'; canvasCtx.lineWidth = 1; const ringCount = 10; for(let i=1; i <= ringCount; i++) { const radius = (i / ringCount) * (w/4) * (1 + Math.sin(orbitalPhase + i*0.5) * 0.1 * speed); canvasCtx.beginPath(); for (let j = 0; j <= complexity; j++) { const angle = (j / complexity) * Math.PI * 2 + orbitalPhase * (i % 2 === 0 ? -1 : 1) * 0.2; const x = w/2 + Math.cos(angle) * radius; const y = h/2 + Math.sin(angle) * radius; if(j === 0) canvasCtx.moveTo(x,y); else canvasCtx.lineTo(x,y); } canvasCtx.stroke(); } }
        function applyDigitalHiveFilter(multiHandLandmarks) { const w = canvasElement.width, h = canvasElement.height; if (w===0) return; const speed = mapValue(handValues[0] || 0, 0, 1000, 0.2, 0.01); const size = 10 + (handValues[1]/1000||0.5)*40; if(hextileGrid.length===0 || hextileGrid[0].size !== size){ hextileGrid = []; const hexW=size*2, hexH=Math.sqrt(3)*size; for(let y=0,r=0; y<h+hexH; y+=hexH/2, r++){ for(let x=0,c=0; x<w+hexW; x+=(hexW*3/4), c++){ hextileGrid.push({x:x+(r%2)*(hexW*3/8), y:y, energy:0, size:size}); } } } canvasCtx.fillStyle='rgba(0,0,0,0.2)'; canvasCtx.fillRect(0,0,w,h); let handPos = []; if(multiHandLandmarks) { handPos = multiHandLandmarks.map(l => ({x: (1-l[8].x)*w, y:l[8].y*h})); } hextileGrid.forEach(hex => { handPos.forEach(hnd => { if(Math.hypot(hex.x-hnd.x, hex.y-hnd.y) < size*2) hex.energy = 1; }); hex.energy -= speed; if(hex.energy<0) hex.energy=0; if(hex.energy>0.01){ canvasCtx.strokeStyle = `rgba(0,255,0,${hex.energy})`; canvasCtx.lineWidth = 1+hex.energy*2; canvasCtx.beginPath(); for(let i=0;i<7;i++){ const angle=Math.PI/3*i-Math.PI/6; canvasCtx.lineTo(hex.x+size*Math.cos(angle), hex.y+size*Math.sin(angle)); } canvasCtx.stroke(); } }); }
        function applyLiquidFlowFilter() { const w = canvasElement.width, h = canvasElement.height; const speed = (handValues[0] / 1000 || 0.1) * 5; const chaosControl = (handValues[1] / 1000) || 0; const fixedTurbulence = 0.01; if (flowParticles.length === 0 && w > 0) { for (let i = 0; i < 14000; i++) { flowParticles.push({ x: Math.random() * w, y: Math.random() * h, chaoticAngle: Math.random() * Math.PI * 2 }); } } canvasCtx.fillStyle = 'rgba(0,0,0,0.05)'; canvasCtx.fillRect(0,0,w,h); canvasCtx.fillStyle = '#0f0'; for(const p of flowParticles) { const orderedAngle = Math.sin(p.x * fixedTurbulence) + Math.cos(p.y * fixedTurbulence); const orderedVx = Math.cos(orderedAngle) * speed; const orderedVy = Math.sin(orderedAngle) * speed; const chaoticVx = Math.cos(p.chaoticAngle) * speed; const chaoticVy = Math.sin(p.chaoticAngle) * speed; const finalVx = (1 - chaosControl) * orderedVx + chaosControl * chaoticVx; const finalVy = (1 - chaosControl) * orderedVy + chaosControl * chaoticVy; p.x += finalVx; p.y += finalVy; if (p.x < 0) p.x += w; if (p.x > w) p.x -= w; if (p.y < 0) p.y += h; if (p.y > h) p.y -= h; canvasCtx.fillRect(p.x, p.y, 1, 1); } }
        function applySpectralGridFilter() { const w = canvasElement.width, h = canvasElement.height; if (w === 0) return; const resolution = 5 + Math.floor((1 - (handValues[0] / 1000 || 0.5)) * 30); const sensitivity = 1 + (handValues[1] / 1000 || 0.2) * 5; const imageData = canvasCtx.getImageData(0,0,w,h); const data = imageData.data; canvasCtx.fillStyle='black'; canvasCtx.fillRect(0,0,w,h); for(let y=0; y<h; y+=resolution) { for(let x=0; x<w; x+=resolution) { const i = (y*w+x)*4; const brightness = (data[i]+data[i+1]+data[i+2])/3/255; const size = brightness * resolution * sensitivity; const hue = 120 + brightness * 100; canvasCtx.fillStyle = `hsl(${hue}, 100%, 50%)`; canvasCtx.beginPath(); canvasCtx.arc(x,y,size/2,0,Math.PI*2); canvasCtx.fill(); } } }
        function applyNeuralModelerFilter(multiHandLandmarks) { const w = canvasElement.width, h = canvasElement.height; const depth = (handValues[0] / 1000 || 0) * 500; const speed = (handValues[1] / 1000 || 0) * 0.1; modelerRotation += speed; canvasCtx.fillStyle = 'rgba(0,0,0,0.1)'; canvasCtx.fillRect(0,0,w,h); if (!multiHandLandmarks) return; let points = []; multiHandLandmarks.forEach(landmarks => { landmarks.forEach(lm => points.push({x: (1-lm.x)*w, y: lm.y*h, z: 0})); }); canvasCtx.save(); canvasCtx.translate(w/2, h/2); const pointsA = points.map(p => ({x: p.x-w/2, y:p.y-h/2, z: -depth/2})); const pointsB = points.map(p => ({x: p.x-w/2, y:p.y-h/2, z: depth/2})); let allPoints = [...pointsA, ...pointsB]; allPoints.forEach(p => { const rotX = p.x * Math.cos(modelerRotation) - p.z * Math.sin(modelerRotation); const rotZ = p.x * Math.sin(modelerRotation) + p.z * Math.cos(modelerRotation); p.x = rotX; p.z = rotZ; }); canvasCtx.strokeStyle = '#0f0'; for (let i=0; i<pointsA.length; i++) { canvasCtx.beginPath(); canvasCtx.moveTo(pointsA[i].x, pointsA[i].y); canvasCtx.lineTo(pointsB[i].x, pointsB[i].y); canvasCtx.stroke(); if (i < pointsA.length - 1) { canvasCtx.beginPath(); canvasCtx.moveTo(pointsA[i].x, pointsA[i].y); canvasCtx.lineTo(pointsA[i+1].x, pointsA[i+1].y); canvasCtx.stroke(); canvasCtx.beginPath(); canvasCtx.moveTo(pointsB[i].x, pointsB[i].y); canvasCtx.lineTo(pointsB[i+1].x, pointsB[i+1].y); canvasCtx.stroke(); } } canvasCtx.restore(); }
        function applyAsciiDistortFilter() { const w = canvasElement.width, h = canvasElement.height; if(w===0) return; const density = handValues[0] / 1000 || 0.5; const distortion = handValues[1] / 1000 || 0; const chars = " .:-=+*#%@"; const resolution = Math.max(8, Math.floor(25 - (density * 20))); const imageData = canvasCtx.getImageData(0, 0, w, h); const data = imageData.data; canvasCtx.fillStyle = 'black'; canvasCtx.fillRect(0,0,w,h); canvasCtx.fillStyle = '#0f0'; canvasCtx.font = `${resolution}px "Press Start 2P"`; for (let y = 0; y < h; y += resolution) { const yOffset = Math.sin(y/(h*0.1) + performance.now()*0.001) * distortion * 50; for (let x = 0; x < w; x += resolution) { const i = (y * w + x) * 4; const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3; const charIndex = Math.floor((brightness / 255) * (chars.length - 1)); canvasCtx.fillText(chars[charIndex], x, y + yOffset); } } }
        function applyParticleFlowFieldFilter() { const w = canvasElement.width, h = canvasElement.height; if(w===0 || !p5Instance) return; const speed = handValues[0] / 1000 || 0.2; const complexity = handValues[1] / 1000 || 0.3; const scale = 10 + (complexity * 40); const force = 0.5 + (speed * 4); if (flowFieldParticles.length === 0 && w > 0) { flowFieldParticles = []; for(let i=0; i<10500; i++) { flowFieldParticles.push({x: Math.random() * w, y: Math.random() * h}); } } canvasCtx.fillStyle = 'rgba(0,0,0,0.07)'; canvasCtx.fillRect(0,0,w,h); canvasCtx.fillStyle = '#0f0'; for(const p of flowFieldParticles) { const angle = p5Instance.noise(p.x / scale, p.y / scale) * Math.PI * 2 * (5 * complexity); p.x += Math.cos(angle) * force; p.y += Math.sin(angle) * force; if(p.x < 0) p.x = w; if(p.x > w) p.x = 0; if(p.y < 0) p.y = h; if(p.y > h) p.y = 0; canvasCtx.fillRect(p.x, p.y, 1, 1); } }
        function applyLissajousCyberscopeFilter() { const w = canvasElement.width, h = canvasElement.height; if(w===0) return; const freqX = 1 + Math.floor((handValues[0] / 1000) * 10) || 3; const freqY = 1 + Math.floor((handValues[1] / 1000) * 10) || 4; if (!lissajousParams.t) { lissajousParams = { t: 0, oldX: w/2, oldY: h/2 }; } canvasCtx.strokeStyle = '#0f0'; canvasCtx.lineWidth = 1.5; canvasCtx.shadowColor = '#0f0'; canvasCtx.shadowBlur = 8; canvasCtx.beginPath(); canvasCtx.moveTo(lissajousParams.oldX, lissajousParams.oldY); for (let i = 0; i < 50; i++) { lissajousParams.t += 0.002; const x = w/2 + (w/2.2) * Math.sin(freqX * lissajousParams.t); const y = h/2 + (h/2.2) * Math.cos(freqY * lissajousParams.t); canvasCtx.lineTo(x, y); lissajousParams.oldX = x; lissajousParams.oldY = y; } canvasCtx.stroke(); canvasCtx.shadowBlur = 0; canvasCtx.fillStyle = 'rgba(0,0,0,0.05)'; canvasCtx.fillRect(0,0,w,h); }
        function applyFrameBufferGlitchFilter() { const w = canvasElement.width, h = canvasElement.height; if(w===0 || !previousFrame) return; const ghosting = handValues[0]/1000 || 0; const corruption = handValues[1]/1000 || 0; if (ghosting > 0.05) { canvasCtx.globalAlpha = ghosting; canvasCtx.drawImage(previousFrame, 0, 0); canvasCtx.globalAlpha = 1; } for(let i=0; i < 20; i++) { if (Math.random() < corruption) { const sx = Math.random() * w; const sy = Math.random() * h; const sw = Math.random() * (w/4); const sh = Math.random() * (h/4); const dx = Math.random() * w; const dy = Math.random() * h; canvasCtx.drawImage(previousFrame, sx, sy, sw, sh, dx, dy, sw, sh); } } }
        function applyStrangeAttractorFilter() { const w = canvasElement.width, h = canvasElement.height; if (w === 0) return; if (!attractorParams.x) { attractorParams = { x: 0.1, y: 0.1 }; } const param1 = mapValue(handValues[0] || 500, 0, 1000, -2.5, 2.5); const param2 = mapValue(handValues[1] || 500, 0, 1000, -2.5, 2.5); const a = param1, b = -1.9, c = param2, d = -1.6; canvasCtx.fillStyle = `rgba(0, 0, 0, 0.05)`; canvasCtx.fillRect(0, 0, w, h); canvasCtx.fillStyle = '#0f0'; for (let i = 0; i < 50000; i++) { let nextX = Math.sin(a * attractorParams.y) + c * Math.cos(a * attractorParams.x); let nextY = Math.sin(b * attractorParams.x) + d * Math.cos(b * attractorParams.y); const logical_range = 4; const logical_min = -2; attractorParams.x = ((nextX - logical_min) % logical_range + logical_range) % logical_range + logical_min; attractorParams.y = ((nextY - logical_min) % logical_range + logical_range) % logical_range + logical_min; const plotX = mapValue(attractorParams.x, -2, 2, 0, w); const plotY = mapValue(attractorParams.y, -2, 2, 0, h); canvasCtx.fillRect(plotX, plotY, 1, 1); } }
        function applyHolographicRainFilter(multiHandLandmarks) { const w = canvasElement.width, h = canvasElement.height; if(w===0) return; const repulsion = 1 + (handValues[0]/1000 || 0.2) * 200; const speed = 2 + (handValues[1]/1000 || 0.3) * 25; const katakana = "01"; if (holorainParticles.length === 0) for(let i=0; i<500; i++) holorainParticles.push({x:Math.random()*w, y:Math.random()*h, z:Math.random()*5, char: katakana[Math.floor(Math.random()*katakana.length)]}); canvasCtx.fillStyle = 'rgba(0,0,0,0.15)'; canvasCtx.fillRect(0,0,w,h); let repulsorPoints = []; if (multiHandLandmarks) { const FINGER_TIP_INDICES = [4, 8, 12, 16, 20]; for (const landmarks of multiHandLandmarks) { for (const index of FINGER_TIP_INDICES) { const tip = landmarks[index]; repulsorPoints.push({ x: (1 - tip.x) * w, y: tip.y * h }); } } } for (const p of holorainParticles) { p.y += speed / (p.z + 1); repulsorPoints.forEach(hnd => { const dx = p.x - hnd.x, dy = p.y - hnd.y; const dist = Math.hypot(dx, dy); if (dist < repulsion) { const forceFactor = 0.15; p.x += (dx/dist) * (repulsion-dist) * forceFactor; p.y += (dy/dist) * (repulsion-dist) * forceFactor; } }); if (p.y > h) { p.y = 0; p.x = Math.random()*w; } const size = 12 / (p.z + 1); canvasCtx.font = `${size}px "Press Start 2P"`; canvasCtx.fillStyle = `hsl(${120 + p.z*20}, 100%, 70%)`; canvasCtx.fillText(p.char, p.x, p.y); } }
        function applyWarpDriveFilter() { const w = canvasElement.width, h = canvasElement.height; if(w===0) return; const speed = (handValues[0]/1000 || 0.01) * 30; const fov = 128 + (handValues[1]/1000 || 0.5) * 400; if (warpdriveStars.length === 0) for(let i=0; i<1500; i++) warpdriveStars.push({x: (Math.random()-0.5)*w, y: (Math.random()-0.5)*h, z:Math.random()*w}); canvasCtx.fillStyle = 'black'; canvasCtx.fillRect(0,0,w,h); canvasCtx.save(); canvasCtx.translate(w/2, h/2); for(const s of warpdriveStars) { s.z -= speed; if(s.z <= 1) s.z = w; const scale = fov/s.z; const sx = s.x * scale, sy = s.y * scale; const old_sx = s.x * (fov / (s.z + speed*2)); const old_sy = s.y * (fov / (s.z + speed*2)); const alpha = (w-s.z)/w; canvasCtx.strokeStyle = `rgba(255,255,255,${alpha})`; canvasCtx.lineWidth = Math.max(1, scale*2); canvasCtx.beginPath(); canvasCtx.moveTo(old_sx, old_sy); canvasCtx.lineTo(sx, sy); canvasCtx.stroke(); } canvasCtx.restore(); }
        function applySynapticFeedbackFilter() { const w = canvasElement.width, h = canvasElement.height; if(w===0 || !previousFrame) return; const zoom = 1.005 + (handValues[0]/1000 || 0.1) * 0.01; const rgbShift = (handValues[1]/1000 || 0) * 5; canvasCtx.save(); canvasCtx.translate(w/2, h/2); canvasCtx.scale(zoom, zoom); canvasCtx.rotate((zoom-1)*0.1); canvasCtx.translate(-w/2, -h/2); canvasCtx.globalAlpha = 0.95; canvasCtx.drawImage(previousFrame, 0, 0, w, h); if (rgbShift > 0.1) { canvasCtx.globalCompositeOperation = 'lighter'; canvasCtx.drawImage(previousFrame, rgbShift, 0, w, h); canvasCtx.drawImage(previousFrame, -rgbShift, 0, w, h); canvasCtx.globalCompositeOperation = 'source-over'; } canvasCtx.restore(); const imageData = canvasCtx.getImageData(0,0,w,h); for(let i=0; i<100; i++) { const x = Math.floor(Math.random()*w), y = Math.floor(Math.random()*h); const b = (imageData.data[(y*w+x)*4] + imageData.data[(y*w+x)*4+1] + imageData.data[(y*w+x)*4+2])/3; if(b > 180) feedbackParticles.push({x, y, life: 50, color: `hsl(${Math.random()*60}, 100%, 80%)`}); } for(const p of feedbackParticles) { p.life--; canvasCtx.fillStyle = p.color; canvasCtx.globalAlpha = p.life/50; canvasCtx.fillRect(p.x, p.y, 2, 2); } feedbackParticles = feedbackParticles.filter(p => p.life > 0); canvasCtx.globalAlpha = 1; }
        function applyAetherFilter(multiHandLandmarks) { const w = canvasElement.width, h = canvasElement.height; if (w === 0) return; const viscosity = 0.85 + (handValues[0] / 1000 || 0.5) * 0.14; const turbulence = (handValues[1] / 1000 || 0.2) * 20; if (aetherParticles.length === 0 && w > 0) { for (let i = 0; i < 25000; i++) { aetherParticles.push({ x: Math.random() * w, y: Math.random() * h, vx: 0, vy: 0 }); } } canvasCtx.fillStyle = 'rgba(0,0,0,0.1)'; canvasCtx.fillRect(0, 0, w, h); let handPos = []; if (multiHandLandmarks) { handPos = multiHandLandmarks.map(l => ({ x: (1 - l[8].x) * w, y: l[8].y * h })); } for (const p of aetherParticles) { handPos.forEach(hnd => { const dx = hnd.x - p.x, dy = hnd.y - p.y, dist = Math.hypot(dx, dy); if (dist < 150) { const force = (150 - dist) / 150; p.vx += dx / dist * force * turbulence * 0.1; p.vy += dy / dist * force * turbulence * 0.1; } }); p.vx *= viscosity; p.vy *= viscosity; p.x += p.vx; p.y += p.vy; if (p.x < 0) { p.x = w } if (p.x > w) { p.x = 0 } if (p.y < 0) { p.y = h } if (p.y > h) { p.y = 0 } canvasCtx.fillStyle = `hsl(180, 100%, 80%)`; canvasCtx.fillRect(p.x, p.y, 1, 1); } }
        function applyContainmentFilter() { const w = canvasElement.width, h = canvasElement.height; if (w === 0) return; const strength = 0.01 + (handValues[0] / 1000 || 0.3) * 0.1; const volatility = (handValues[1] / 1000 || 0.1); const zoomFactor = 1 + volatility * 12; if (containmentParticles.length === 0) { for (let i = 0; i < 9000; i++) { const spawnRadiusX = w * 4; const spawnRadiusY = h * 4; containmentParticles.push({ x: w / 2 + (Math.random() - 0.5) * spawnRadiusX, y: h / 2 + (Math.random() - 0.5) * spawnRadiusY, vx: 0, vy: 0 }); } } canvasCtx.fillStyle = 'rgba(0,0,0,0.1)'; canvasCtx.fillRect(0, 0, w, h); const centerX = w / 2; const centerY = h / 2; for (const p of containmentParticles) { p.vx += (centerX - p.x) * strength; p.vy += (centerY - p.y) * strength; p.vx *= 0.9; p.vy *= 0.9; p.x += p.vx; p.y += p.vy; if (Math.random() < volatility * 0.01) { const angle = Math.random() * 2 * Math.PI; const force = volatility * 10; p.vx += Math.cos(angle) * force; p.vy += Math.sin(angle) * force; } const relativeX = p.x - centerX; const relativeY = p.y - centerY; const drawX = centerX + relativeX * zoomFactor; const drawY = centerY + relativeY * zoomFactor; canvasCtx.fillStyle = '#0f0'; canvasCtx.fillRect(drawX, drawY, 1, 1); } }
        function applyCryoShardsFilter(multiHandLandmarks) { const w = canvasElement.width, h = canvasElement.height; if(w===0) return; const crystalRate = (handValues[0]/1000 || 0.2); const heat = 1 + (handValues[1]/1000 || 0.1)*200; canvasCtx.fillStyle='rgba(0,0,0,0.1)'; canvasCtx.fillRect(0,0,w,h); if(Math.random() < crystalRate) for(let i=0; i<5; i++) cryoShards.push({x:Math.random()*w, y:Math.random()*h, life:100}); let handPos = []; if (multiHandLandmarks) handPos = multiHandLandmarks.map(l => ({x: (1-l[8].x)*w, y:l[8].y*h})); cryoShards.forEach((s, i) => { s.life--; let closest=null, minDist=Infinity; cryoShards.forEach((o,j)=>{if(i===j)return; const d=Math.hypot(s.x-o.x, s.y-o.y); if(d<minDist){minDist=d; closest=o;}}); if(closest && minDist < 100){ canvasCtx.beginPath(); canvasCtx.moveTo(s.x, s.y); canvasCtx.lineTo(closest.x, closest.y); canvasCtx.strokeStyle=`rgba(180, 220, 255, ${s.life/100 * 0.5})`; canvasCtx.stroke();} handPos.forEach(hnd => { if(s.life > 0 && Math.hypot(s.x-hnd.x, s.y-hnd.y) < heat){ s.life=0; for(let k=0; k<10; k++) cryoParticles.push({x:s.x, y:s.y, vx:(Math.random()-0.5) * 4, vy:(Math.random()-0.5)*4 - 1.5, life:60}); if(closest && minDist < 100){ closest.life = 0; for(let k=0; k<10; k++) cryoParticles.push({x:closest.x, y:closest.y, vx:(Math.random()-0.5) * 4, vy:(Math.random()-0.5)*4 - 1.5, life:60}); const numLineParticles = 20; for (let j = 1; j < numLineParticles; j++) { const t = j / numLineParticles; const px = s.x + (closest.x - s.x) * t; const py = s.y + (closest.y - s.y) * t; cryoParticles.push({x: px, y: py, vx:(Math.random()-0.5) * 4, vy:(Math.random()-0.5)*4 - 1.5, life: 60}); } } } }); }); cryoShards = cryoShards.filter(s=>s.life>0); while(cryoShards.length > 300) cryoShards.shift(); cryoParticles.forEach(p=>{p.x+=p.vx;p.y+=p.vy;p.life--; canvasCtx.fillStyle=`rgba(200,230,255,${p.life/50})`; canvasCtx.fillRect(p.x,p.y,2,2);}); cryoParticles = cryoParticles.filter(p=>p.life>0); }
        function applyGravityWellFilter(multiHandLandmarks) { const w = canvasElement.width, h = canvasElement.height; if (w === 0) return; const mass1 = (handValues[0] / 1000 || 0.3) * 2000; const mass2 = (handValues[1] / 1000 || 0.3) * 2000; let wells = [{ x: w / 4, y: h / 2, mass: mass1 }, { x: w * 3 / 4, y: h / 2, mass: mass2 }]; if (multiHandLandmarks && multiHandLandmarks.length > 0) { wells[0].x = (1 - multiHandLandmarks[0][8].x) * w; wells[0].y = multiHandLandmarks[0][8].y * h; } if (multiHandLandmarks && multiHandLandmarks.length > 1) { wells[1].x = (1 - multiHandLandmarks[1][8].x) * w; wells[1].y = multiHandLandmarks[1][8].y * h; } if (gravityParticles.length === 0 && w > 0) { for (let i = 0; i < 50000; i++) { gravityParticles.push({ x: Math.random() * w, y: Math.random() * h, vx: 0, vy: 0 }); } } canvasCtx.fillStyle = 'rgba(0,0,0,0.1)'; canvasCtx.fillRect(0, 0, w, h); for (const p of gravityParticles) { wells.forEach(well => { const dx = well.x - p.x, dy = well.y - p.y, distSq = dx * dx + dy * dy; if (distSq > 400) { const force = well.mass / distSq; p.vx += dx * force; p.vy += dy * force; } }); p.x += p.vx; p.y += p.vy; p.vx *= 0.99; p.vy *= 0.99; if (p.x < 0 || p.x > w || p.y < 0 || p.y > h) { p.x = Math.random() * w; p.y = Math.random() * h; p.vx = 0; p.vy = 0; } canvasCtx.fillStyle = '#0f0'; canvasCtx.fillRect(p.x, p.y, 1, 1); } }
        function applyVoxelDecompFilter() { const w = canvasElement.width, h = canvasElement.height; if(w===0) return; const resolution = 5 + Math.floor((1-(handValues[0]/1000||0.5))*30); const entropy = (handValues[1]/1000||0.1); const imageData = videoElement.videoWidth > 0 ? canvasCtx.getImageData(0,0,w,h) : null; canvasCtx.fillStyle='rgba(0,0,0,0.2)'; canvasCtx.fillRect(0,0,w,h); if(imageData) { for(let y=0; y<h; y+=resolution) { for(let x=0; x<w; x+=resolution) { const i=(y*w+x)*4; const color=`rgb(${imageData.data[i]}, ${imageData.data[i+1]}, ${imageData.data[i+2]})`; if(Math.random() < entropy*0.1) { for(let k=0; k<3; k++) { voxelDecompParticles.push({x:x, y:y, vx:(Math.random()-0.5), vy:0, life:100, color:color}); } } else { canvasCtx.fillStyle = color; canvasCtx.fillRect(x, y, resolution, resolution); } } } } for(const p of voxelDecompParticles) { p.x+=p.vx; p.y+=p.vy; p.vy+=0.1; p.life--; canvasCtx.fillStyle=p.color; canvasCtx.globalAlpha = p.life/100; canvasCtx.fillRect(p.x,p.y,3,3); } voxelDecompParticles = voxelDecompParticles.filter(p=>p.life>0); canvasCtx.globalAlpha=1; }
        function applyBifurcationFilter() { const w=canvasElement.width, h=canvasElement.height; if(w===0)return; const r_min = 2.8 + (handValues[0]/1000||0)*1.1; const r_range = 0.1 + (1-(handValues[0]/1000||0))*0.1; const density = 100 + (handValues[1]/1000||0.2)*400; canvasCtx.fillStyle='rgba(0,0,0,0.1)'; canvasCtx.fillRect(0,0,w,h); canvasCtx.fillStyle='#0f0'; for(let i=0; i<density*10; i++){ const r = r_min + (Math.random()*r_range); let x=0.5; for(let j=0; j<500; j++) x = r*x*(1-x); for(let j=0; j<50; j++){ x = r*x*(1-x); const px = mapValue(r, r_min, r_min+r_range, 0, w); const py = mapValue(x, 0, 1, h, 0); canvasCtx.fillRect(px,py,1,1); } } }
        function applyRelativisticJetFilter(multiHandLandmarks) { const w = canvasElement.width, h = canvasElement.height; if (w === 0) return; let emitters = []; if (multiHandLandmarks && multiHandLandmarks.length > 0) { for(let i = 0; i < multiHandLandmarks.length; i++) { const landmarks = multiHandLandmarks[i]; const tip = landmarks[8]; const currentHandValue = handValues[i] || 200; const currentTurbulence = (handValues[i === 0 ? 1 : 0] / 1000 || 0.1) * 0.2; emitters.push({ x: (1 - tip.x) * w, y: tip.y * h, collimation: mapValue(currentHandValue, 0, 1000, 0.5, 0.01), turbulence: currentTurbulence }); } } else { emitters.push({ x: w / 2, y: h, collimation: 0.2, turbulence: 0.1 }); } canvasCtx.fillStyle = 'rgba(0,0,0,0.1)'; canvasCtx.fillRect(0, 0, w, h); for (const emitter of emitters) { const particlesPerEmitter = 75; for (let i = 0; i < particlesPerEmitter; i++) { const angle = (Math.random() - 0.5) * emitter.collimation * Math.PI; jetParticles.push({ x: emitter.x, y: emitter.y, vx: Math.sin(angle), vy: -Math.cos(angle), life: 100, turbulence: emitter.turbulence }); } } for (const p of jetParticles) { p.x += p.vx * p.life * 0.1; p.y += p.vy * p.life * 0.1; p.vy += (p5Instance.noise(p.x * 0.01, performance.now() * 0.0001) - 0.5) * p.turbulence; p.life--; const hue = 120 + p.life / 3; canvasCtx.fillStyle = `hsla(${hue}, 100%, 70%, ${p.life / 100})`; canvasCtx.beginPath(); canvasCtx.arc(p.x, p.y, p.life / 50, 0, Math.PI * 2); canvasCtx.fill(); } jetParticles = jetParticles.filter(p => p.life > 0 && p.x > 0 && p.x < w && p.y > 0 && p.y < h); }
        function applyLorenzAttractorFilter() { const w=canvasElement.width, h=canvasElement.height; if(w===0)return; if (!handValues || handValues.length === 0) { return; } const rho = mapValue(handValues[0], 0, 1000, 24, 90); const scale = mapValue(handValues.length > 1 ? handValues[1] : 500, 0, 1000, 4, 15); const sigma=10; const beta=8/3; const dt=0.01; const z_center=rho-1; canvasCtx.fillStyle='rgba(0,0,0,0.1)'; canvasCtx.fillRect(0,0,w,h); canvasCtx.save(); canvasCtx.translate(w/2, h/2); canvasCtx.fillStyle='#0f0'; for(let i=0; i<30000; i++){ const dx = (sigma * (lorenzState.y - lorenzState.x)) * dt; const dy = (lorenzState.x * (rho - lorenzState.z) - lorenzState.y) * dt; const dz = (lorenzState.x * lorenzState.y - beta * lorenzState.z) * dt; lorenzState.x+=dx; lorenzState.y+=dy; lorenzState.z+=dz; if (Math.abs(lorenzState.x) > 100 || Math.abs(lorenzState.y) > 100 || Math.abs(lorenzState.z) > 200) { lorenzState = { x: 0.1, y: 0, z: 0 }; continue; } const px = lorenzState.x * scale; const py = (lorenzState.z - z_center) * scale; canvasCtx.fillRect(px,py,1,1); } canvasCtx.restore(); }
        function applyCliffordFilter() { const w = canvasElement.width, h = canvasElement.height; if (w === 0) return; const a = mapValue(handValues[0] || 500, 0, 1000, -2, 2); const b = mapValue(handValues[1] || 500, 0, 1000, -2, 2); const c = -1.2, d = -1.2; canvasCtx.fillStyle = 'rgba(0,0,0,0.1)'; canvasCtx.fillRect(0, 0, w, h); canvasCtx.fillStyle = '#0f0'; for (let i = 0; i < 50000; i++) { const nextX = Math.sin(a * cliffordState.y) + c * Math.cos(a * cliffordState.x); const nextY = Math.sin(b * cliffordState.x) + d * Math.cos(b * cliffordState.y); const logical_range = 4; const logical_min = -2; cliffordState.x = ((nextX - logical_min) % logical_range + logical_range) % logical_range + logical_min; cliffordState.y = ((nextY - logical_min) % logical_range + logical_range) % logical_range + logical_min; const plotX = mapValue(cliffordState.x, -2, 2, 0, w); const plotY = mapValue(cliffordState.y, -2, 2, 0, h); canvasCtx.fillRect(plotX, plotY, 1, 1); } }
        function applyHopalongFilter() { const w = canvasElement.width, h = canvasElement.height; if (w === 0) return; const currentTime = performance.now(); if (hopalongLastResetTime === 0) { hopalongLastResetTime = currentTime; } if (currentTime - hopalongLastResetTime > 30000) { hopalongState = {x: 0, y: 0}; hopalongLastResetTime = currentTime; } const a = mapValue(handValues[0] || 500, 0, 1000, -Math.PI, Math.PI); const hand2Value = handValues[1] || 700; const b = mapValue(hand2Value, 0, 1000, 0.1, 2.0); const c = mapValue(hand2Value, 0, 1000, 0, 10); const scale = mapValue(hand2Value, 0, 1000, w / 40, w / 800); canvasCtx.fillStyle = 'rgba(0,0,0,0.1)'; canvasCtx.fillRect(0, 0, w, h); canvasCtx.save(); canvasCtx.translate(w / 2, h / 2); canvasCtx.fillStyle = '#0f0'; for (let i = 0; i < 25000; i++) { const nextX = hopalongState.y - Math.sign(hopalongState.x) * Math.sqrt(Math.abs(b * hopalongState.x - c)); const nextY = a - hopalongState.x; hopalongState.x = nextX; hopalongState.y = nextY; let drawX = hopalongState.x * scale; let drawY = hopalongState.y * scale; const halfW = w / 2; const halfH = h / 2; if (drawX > halfW) { drawX -= w; } else if (drawX < -halfW) { drawX += w; } if (drawY > halfH) { drawY -= h; } else if (drawY < -halfH) { drawY += h; } canvasCtx.fillRect(drawX, drawY, 1, 1); } canvasCtx.restore(); }
        
        const filterFunctions = { 'bleed': applyDataBleedFilter, 'ascii': applyAsciiFilter, 'neural': applyNeuralNetworkFilter, 'voronoi': applyVoronoiShatterFilter, 'virtualboy': applyVirtualBoyFilter, 'synapse': applyCyberSynapseFilter, 'trace': applyTraceCorridorsFilter, 'orbital': applyOrbitalArrayFilter, 'hive': applyDigitalHiveFilter, 'liquidflow': applyLiquidFlowFilter, 'spectral': applySpectralGridFilter, 'modeler': applyNeuralModelerFilter, 'asciidistort': applyAsciiDistortFilter, 'flowfield': applyParticleFlowFieldFilter, 'cyberscope': applyLissajousCyberscopeFilter, 'frameglitch': applyFrameBufferGlitchFilter, 'attractor': applyStrangeAttractorFilter, 'holorain': applyHolographicRainFilter, 'warpdrive': applyWarpDriveFilter, 'feedback': applySynapticFeedbackFilter, 'aether': applyAetherFilter, 'containment': applyContainmentFilter, 'cryoshards': applyCryoShardsFilter, 'gravity_well': applyGravityWellFilter, 'voxel_decomp': applyVoxelDecompFilter, 'bifurcation': applyBifurcationFilter, 'jet': applyRelativisticJetFilter, 'lorenz': applyLorenzAttractorFilter, 'clifford': applyCliffordFilter, 'hopalong': applyHopalongFilter };

        // --- SECTION DE CONFIGURATION ET ÉVÉNEMENTS ---
        const camera = new Camera(videoElement, { onFrame: async () => { if (videoElement.readyState >= 2) { await hands.send({ image: videoElement }); if (settings.isFaceDetectionActive) { await faceDetection.send({ image: videoElement }); } } }, width: 1280, height: 720 });
        camera.start();
        
        function updateFilterMenuLayout() {
            if (filterSelectionMenu.classList.contains('hidden') || numFilters === 0) return;
            const menuStyle = getComputedStyle(filterSelectionMenu);
            const availableWidth = filterSelectionMenu.clientWidth - parseInt(menuStyle.paddingLeft) - parseInt(menuStyle.paddingRight);
            const availableHeight = filterSelectionMenu.clientHeight - parseInt(menuStyle.paddingTop) - parseInt(menuStyle.paddingBottom);
            let bestLayout = { cols: 1, rows: numFilters, maxSize: 0 };
            for (let cols = 1; cols <= numFilters; cols++) {
                const rows = Math.ceil(numFilters / cols);
                const buttonWidth = availableWidth / cols;
                const buttonHeight = availableHeight / rows;
                const potentialSize = Math.min(buttonWidth, buttonHeight);
                if (potentialSize > bestLayout.maxSize) {
                    bestLayout = { cols: cols, rows: rows, maxSize: potentialSize };
                }
            }
            filterSelectionMenu.style.gridTemplateColumns = `repeat(${bestLayout.cols}, 1fr)`;
            filterSelectionMenu.style.gridTemplateRows = `repeat(${bestLayout.rows}, 1fr)`;
        }

        function resizeCanvas() { 
            canvasElement.width = window.innerWidth; 
            canvasElement.height = window.innerHeight;
            
            previousFrame = null;
            if(canvasElement.width > 0) {
                const filterStatesToReset = [flowParticles, traceWalkers, synapseParticles, flowFieldParticles, attractorParams, holorainParticles, warpdriveStars, feedbackParticles, aetherParticles, containmentParticles, cryoShards, cryoParticles, gravityParticles, voxelDecompParticles, bifurcationParticles, jetParticles, hextileGrid];
                filterStatesToReset.forEach(state => { if(Array.isArray(state)) state.length = 0; else if(typeof state === 'object') { for (const key in state) delete state[key]; }});
                lissajousParams = {};
                lorenzState = { x: 0.1, y: 0, z: 0 };
                cliffordState = {x: 0, y: 0}; hopalongState = {x: 0, y: 0};
                hopalongLastResetTime = 0;
            }
            updateFilterMenuLayout(); 
        }
        
        window.addEventListener('load', resizeCanvas);
        window.addEventListener('resize', resizeCanvas);

        maxNumHandsSlider.addEventListener('input', (e) => { settings.maxNumHands = parseFloat(e.target.value); hands.setOptions({ maxNumHands: settings.maxNumHands }); });
        filterSelect.addEventListener('change', (e) => { settings.selectedFilter = e.target.value; hopalongLastResetTime = 0; });
        filterCheckbox.addEventListener('change', (e) => { settings.isFilterActive = e.target.checked; });
        faceDetectionCheckbox.addEventListener('change', (e) => { settings.isFaceDetectionActive = e.target.checked; });
        volumeSlider.addEventListener('input', (e) => { settings.globalVolume = parseFloat(e.target.value); });
        
        fullscreenCheckbox.addEventListener('change', (e) => {
            if (e.target.checked) {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                }
            } else {
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                }
            }
        });
        document.addEventListener('fullscreenchange', () => {
            fullscreenCheckbox.checked = !!document.fullscreenElement;
        });
        document.addEventListener('keydown', (event) => { 
            if (event.key.toLowerCase() === 'p') { 
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    document.exitFullscreen();
                }
            }
        });

        resetButton.addEventListener('click', () => {
            maxNumHandsSlider.value = 2; filterSelect.value = 'ascii'; filterCheckbox.checked = false;
            faceDetectionCheckbox.checked = false;
            settings.maxNumHands = 2; settings.selectedFilter = 'ascii'; settings.isFilterActive = false;
            settings.isFaceDetectionActive = false;
            const filterStatesToReset = [flowParticles, traceWalkers, synapseParticles, flowFieldParticles, attractorParams, holorainParticles, warpdriveStars, feedbackParticles, aetherParticles, containmentParticles, cryoShards, cryoParticles, gravityParticles, voxelDecompParticles, bifurcationParticles, jetParticles, hextileGrid];
            filterStatesToReset.forEach(state => { if(Array.isArray(state)) state.length = 0; else if(typeof state === 'object') { for (const key in state) delete state[key]; }});
            lissajousParams = {};
            lorenzState = { x: 0.1, y: 0, z: 0 };
            cliffordState = {x: 0, y: 0}; hopalongState = {x: 0, y: 0};
            hopalongLastResetTime = 0;
            initializeHands();
        });
        startGameButton.addEventListener('click', startGame);
        
        function populateFilterMenu() {
            const options = filterSelect.options;
            numFilters = options.length;
            for (let i = 0; i < options.length; i++) {
                const option = options[i];
                const button = document.createElement('button');
                button.textContent = option.textContent;
                button.dataset.filterValue = option.value;
                button.addEventListener('click', () => {
                    filterSelect.value = option.value;
                    filterCheckbox.checked = true;
                    settings.selectedFilter = option.value;
                    settings.isFilterActive = true;
                    filterSelectionMenu.classList.add('hidden');
                    hopalongLastResetTime = 0; 
                });
                filterSelectionMenu.appendChild(button);
            }
        }

        modeButton.addEventListener('click', () => { 
            filterSelectionMenu.classList.toggle('hidden');
            updateFilterMenuLayout();
        });

        showGuiButton.addEventListener('click', () => {
            guiElement.classList.remove('hidden');
            showGuiButton.classList.add('hidden');
        });

        hideGuiButton.addEventListener('click', () => {
            guiElement.classList.add('hidden');
            showGuiButton.classList.remove('hidden');
        });
        
        navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => { videoElement.srcObject = stream; }).catch((err) => { console.error("Erreur d'accès à la webcam: " + err); alert("Impossible d'accéder à la webcam."); });

        // --- Initialisation au démarrage ---
        initializeHands();
        initializeFaceDetection();
        populateFilterMenu();
    </script>
</body>
</html>
